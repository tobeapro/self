## 隐式转换

> 开门见山，js作为一个动态类型语言，有一个特殊也是被诟病的特性就是隐式转换了。

先举个例子吧，在平时的工作场景中，比如我们后端返回的数据是一个数组的时候，我们常常会对数据对一些处理。

```javascript
// response.send({data:[{a:1,b:2,c:3}]}) 
const resData = response.data //比如这是返回的值
```

这时候如果需要把所有的值求和，那也很简单就是循环求和一次。但是呢你想的不一定是你预期的。万一没有数据，而且后端给你返回的数据不是空数组而是undefined、空字符或者null时，是无法使用数组的方法的。所以产生如下我们常用的方式:

```javascript
if(resData&&resData.length){
    // your code 
}
```

我们先做一次隐式转换再通过判断数组长度大于0时在进行相应操作。问题是解决了，根据平时经验似乎也知道了`[]`在隐式转换中是被当成`true`的。

这时候再看个例子

```javascript
[]==true //结果是false,陷入沉思
```

再来个

```javascript
![]==true //结果还是false,这咋办呦
```

为什么刚才前面那个判断的时候`[]`会当作`true`，到这就出问题了呢。首先哪些数据`隐式转换成布尔类型`时会是false呢,主要有`false`,`0`,`-0`,`null`,`undefined`,`''`,`NaN`。其他会都是`true`。这里要注意的是转换成`布尔类型`的时候,在`if`条件判断中是直接转换成布尔类型的,所以空数组是会被转换成`true`。

##### 在`==`判断相等的隐式转换中的主要规则为:

1. 如果比较的两者中有布尔值，会把 `Boolean` 先转换为对应的 Number，即 0 或 1，然后进行比较。
2. 如果比较的双方中有一方为 `Number`，一方为 `String`时，会把 `String` 通过 `Number()` 方法转换为数字，然后进行比较。
3. 如果比较的双方中有一方为 `Boolean`，一方为 `String`时，会将双方转换为数字，然后再进行比较。
4. 如果比较的双方中有一方为 `Number`，一方为`Object`时，则会调用 `valueOf` 方法将`Object`转换为数字，然后进行比较。

```
对象-->>字符-->>数字<<--布尔值 
```



规则如上所示，所以刚才的例子，空数组(对象)和布尔值比较时，会先转换成字符串，再变成数字；而布尔值呢会转换成数字，这样同类型进行比较。

``` 
[]-->>''-->>0 
true-->1 
//所以 0==1为false
```

而后面那个例子对空数组直接去反，会让数据直接转成布尔类型,`[]`转成`布尔类型`时为`true`，如下

```
![]==true //!true==true,所以为false
```

所以我们判断一个数据是否为`true`,可以使用两次取反的方式

```javascript
!![]==true //这样结果就是true了
```

我总结的就是，当两个数据类型不同时，会先进行隐式转换成相同类型然后再进行相应操作，具体转换为何种类型也是和相应的场景相关。

除了`==`判断，在`+`计算中隐式转换也是非常明显的

```javascript
1+2 //3
1+'2' //'12'
{}+[] //0
[]+{} //'[object Object]'
```

为什么出现这种情况呢，还是介绍些基础吧。

#### 1.js数据类型

> 数据类型主要分为两类：原始类型，对象类型

原始类型包含：

`undefined`、`null`、`string`、`number`、`boolean`、`symbol`

对象类型：

`object`

#### 2.发生隐式转换的场景

> `+`运算和`==`比较

#### 3.然后从代码层面看隐式转换的规则

> Object.prototype作为原型链的顶端，他有两个方法`valueOf`和`toString`

##### 结合前面的规格和这两个方法来说明隐式转换：

3.1、如果输入的值是一个原始值，那么直接返回它

3.2、否则，调用这个对象的`toString`方法，如果得到一个原始值，那么就返回

3.3、否则，如果输入的值是一个对象，就调用`valueOf`方法，如果得到的是一个原始值，就返回

3.4、否则，就抛出异常了。

##### 再次综上，解释刚才的表达式

```javascript
{}+[] //0，这里{}比较特殊会被当成一个语句块,所以只剩下了+[]，这时[]转换成0
[]+{} //'[object Object]'，[]转成string会变成''，而{}转成string为'[object Object]'
```

关于`valueOf`方法，Number、Boolean、String这三个构造函数生成的值，其valueOf转换后就是其对应的原始值；而Date构造函数声明的比较特殊，它的valueOf对应的是时间戳的数值；其他的值使用valueOf转换以后都是指向`this`即对象自身

```javascript
const num = new Number(123);
num.valueOf(); //123
const str = new String('abc');
str.valueOf(); //'abc'
const bool = new Boolean('asd');
bool.valueOf(); //true
const date = new Date();
date.valueOf(); //1549272773228
const ary = new Array([1,2,3]);
ary.valueOf(); //[Array(3)]
ary.valueOf() === ary; //true
```

##### 这样就大概把隐式转换理了一下了





